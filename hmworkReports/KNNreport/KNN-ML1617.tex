	\documentclass{article}
			
		\usepackage{parskip}
		\usepackage{listings}
		\usepackage{xcolor}
		\usepackage{textcomp}
			
		%STYLE AND COLOR DEFINITION FOR SOURCE CODE 	
		\newcommand{\PHPamountofcolor}{75}
		\newcommand{\SourceCodeContext}{5}
		%Lets define the php language colors:
		\definecolor{PHP_comment_old}{HTML}{FF8000}
		\colorlet{PHP_comment}{PHP_comment_old!\PHPamountofcolor!black}
		\definecolor{PHP_default_old}{HTML}{000000}
		\colorlet{PHP_default}{PHP_default_old!\PHPamountofcolor!black}
		\definecolor{PHP_keyword_old}{HTML}{6c9c11}
		\colorlet{PHP_keyword}{PHP_keyword_old!\PHPamountofcolor!black}
		\definecolor{PHP_emph1_old}{HTML}{0F58A2}
		\colorlet{PHP_emph1}{PHP_emph1_old!\PHPamountofcolor!black}
		\definecolor{PHP_emph2_old}{HTML}{CCAA00}
		\colorlet{PHP_emph2}{PHP_emph2_old!\PHPamountofcolor!black}
		\definecolor{PHP_emph4_old}{HTML}{C60484}
		\colorlet{PHP_emph4}{PHP_emph4_old!\PHPamountofcolor!black}
		\definecolor{PHP_string_old}{HTML}{C78F0A}
		\colorlet{PHP_string}{PHP_string_old!\PHPamountofcolor!black}
		\definecolor{PHP_variable_old}{HTML}{C82210}%C82210
		\colorlet{PHP_variable}{PHP_variable_old!\PHPamountofcolor!black}
		\definecolor{PHP_number_old}{HTML}{BF1CA6}
		\colorlet{PHP_number}{PHP_number_old!\PHPamountofcolor!black}
		%Now we want to highlight the variables. This will be done by triggering the function \PHPhighlightvar at the start of any $ run. This function wil only highlight variables and any other identifiers will be ignored. Luckily lstlisting will only give correct identifiers so we only will have to check if the previous call was made with a $
		\usepackage{fontspec}
		\setmonofont{Courier}
		%\usepackage[utf8]{inputenc}
		%\usepackage[T1]{fontenc}
		%\usepackage{courier, textcomp}
		\usepackage{etoolbox}
		\newtoggle{InString}{}% Keep track of if we are within a string
		\togglefalse{InString}% Assume not initally in string
		
		\newcommand*{\ColorIfNotInString}[1]{\iftoggle{InString}{#1}{\color{PHP_number}#1}}%

		%helper
		
		\newcommand{\PHPhighlightvar}[1]{\ifnum\theDollarFlag=1 \color{PHP_variable} \fi#1\setcounter{DollarFlag}{0}}
		\newcounter{DollarFlag}
		
		%images
		\usepackage{graphicx}
		\graphicspath{ {images/} }
		\usepackage{wrapfig}
		\usepackage{subcaption}
		
		
			
			
			
		
			
			\title{Machine Learning: Search Algorithms Comparison \\ \bigskip \large  Brief report based on AIMA project sperimentations }

			\author{Edoardo Ghini}
			
			\begin{document}
			
			\textbf{\maketitle}
			\pagenumbering{gobble}
			
			\bigskip\bigskip\bigskip
			\begin{center}
			\includegraphics[width=0.5\textwidth]{laSapienza}
			\end{center}
			\bigskip\bigskip\bigskip
			\textbf{
			Dipartimento di Ingegneria dell'Universit√† di Roma La Sapienza}
			

			\newpage
			\pagenumbering{roman}
			\tableofcontents
			\newpage
			\pagenumbering{arabic}
			
			
			
			
			
			%SETTING STYLE OF SOURCE CODE
			\lstset{
		  language        = php,
		  basicstyle      = \footnotesize\ttfamily,
		  keywordstyle    = \color{PHP_keyword},
		  stringstyle     = \color{PHP_string!90!black}\toggletrue{InString},
		  %this allows highlighting of variables:
		  literate        =  {\$}{{\iftoggle{InString}{\$}{\setcounter{DollarFlag}{1}\color{PHP_variable}\$\color{PHP_default}}}}1
		%    {"}{{{\ProcessQuote{"}}}}1% Disable coloring within double quotes
		%    {'}{{{\ProcessQuote{'}}}}1% Disable coloring within single quote
		    {0}{{{\ColorIfNotInString{0}}}}1
		    {1}{{{\ColorIfNotInString{1}}}}1
		    {2}{{{\ColorIfNotInString{2}}}}1
		    {3}{{{\ColorIfNotInString{3}}}}1
		    {4}{{{\ColorIfNotInString{4}}}}1
		    {5}{{{\ColorIfNotInString{5}}}}1
		    {6}{{{\ColorIfNotInString{6}}}}1
		    {7}{{{\ColorIfNotInString{7}}}}1
		    {8}{{{\ColorIfNotInString{8}}}}1
		    {9}{{{\ColorIfNotInString{9}}}}1,
		  identifierstyle = \color{PHP_default}\PHPhighlightvar,
		  commentstyle    = \color{PHP_comment}\slshape,
		  emph            =[1]{require_once, require, include_once, include, namespace, use, class, function, new},
		  emphstyle       =[1]\color{PHP_emph1},%\bf,
		  emph            =[2]{echo, empty, isset, array, instanceof},
		  emphstyle       =[2]\color{PHP_emph2},%\bf,
		  emph            =[3]{var, const, abstract, 
		                        protected, private, public,
		                        static, final, extends, implements,
		                        global, if, else, foreach ,for,
		                        endforeach, endif, endfor, elseif,
		                        as},
		  emphstyle       =[3]\color{PHP_keyword},%\bf,
		  emph            =[4]{return, throw, exit, __halt_compiler, continue, break},
		  emphstyle       =[4]\color{PHP_emph4},%\bf,
		  breaklines      = true,
		  captionpos      = b,
		  rulecolor       =\color{black},
		  keywords    ={__halt_compiler,    abstract,   and,    array,
		                    as, break,  callable,   case,   catch,  class,
		                    clone,  const,  continue,   declare,    default,
		                    die,    do, echo,   else,   elseif,
		                    empty,  enddeclare, endfor, endforeach, endif,
		                    endswitch,  endwhile,   eval,   exit,   extends,
		                    final,  finally,    for,    foreach,    function,
		                    global, goto, if,   implements, include,
		                    include_once,   instanceof, insteadof,
		                    interface,  isset, list,    namespace,
		                    new,    or, print, private, protected,  public,
		                    require,    require_once, return,   static,
		                    switch, throw,  trait, try, unset, use, var,
		                    while,  xor,    yield,
		  },
		  numbers=left,
		  stepnumber=1,  
		  numberfirstline=true,
		  numberstyle=\footnotesize,
		  xleftmargin=4.0ex,
		  upquote=true,
		  showlines=true
		  }	
			
			\renewcommand{\lstlistingname}{Code}

			
			\part{Introduction}
			
				\section{AIMA project}
At the very beginning I tryed to explore and understand some small sections of the AIMA project code in order to aquire some proficency with the search algorithm implementations.\medskip\\
 Consequently, I  ran the application watching closely the algorithm executions with the aid of debugging view.
				\section{Original project emulation}
In order to fullfill the assignment tasks I took the cue from some classes already implemented ( e.g. PuzzleBoard, NQueensDemo, FunctionFactory etc.).\medskip\\
After that I started to implement a parallel group of classes following the same hierachy logic implemented in the AIMA project.
				\section{Thoughts on observed results}
After a while, when the backend implementation was been completed, I began to plot some statistics on the algorithm outcomes.\medskip\\
Finally, I drawn my own conclusions according to evident features that characterize the employed search algorithms.
\newpage
			\part{Development}
				\section{NQueens Search Problem}
	The implementations of the search algorithms were useful while I was developing the class Plotter that, using `JfreeChart` , draws plots of the resource usage (in terms of space in main memory and time) during the execution of various algorithms.\medskip\\
These shown below are some observations on graphs that describe algorithm results on the "N Queens" problem.
					\subsection{Time}
					\begin{center}
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{QueenSearchPlotThreeAlgosTime}
\caption{}
\label{fig:1}
\end{figure}
\end{center}

As shown in fig.(1) there are significative discrepancies between time performances :  the two fastest algorithms are Depth First Search and Recursive Depth Limited Search, in this particular case seems that the choose of the depth limit is optimal.\\
Furthermore the similarity between the two is somewhat expected because DLS search uses a depth first policy to visit the limited search tree.\medskip\\
On the other hand the Iterative Deepening Approach is acceptable with very simple configurations and small search trees, but when the complexity grows, it will require more and more time in an exponential trend.\medskip\\

\begin{center}
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{QueenSearchPlotOnlySimulatedAnnealing}
\caption{}
\label{fig:2}
\end{figure}
\end{center}

\begin{center}
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{QueenSearchPlotOnlyGenerative}
\caption{}
\label{fig:3}
\end{figure}
\end{center}

In fig(2) end fig(3) there are statistics about two other king of search algorithms. The former chart shows how the Simulated Annealing strategy could give very unpredictable results (in this case rather good) and is not always guaranteed to solve the problem, unless we allow the algorithm to run slowly enough.\medskip\\
The latter is about an application of the Generative Algorithm to the problem. Its is the worst performance among contemplated algorithms, in fact it won't converge to the solution in an acceptable time when the board size is greater than ten.

					\subsection{Nodes expanded}
					
\begin{center}
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{QueenSearchPlotNodesExpandedBest}
\caption{}
\label{fig:4}
\end{figure}
\end{center}
		
		
\begin{center}
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{QueenSearchPlotNodesExpandedTwoWorst}
\caption{}
\label{fig:5}
\end{figure}
\end{center}

According to the plot in fig.(4) I noticed that Depth First Approach can be very convenient also in terms of visited states(nodes), when the search space is small this is probably the best way to expand the lowest number of nodes.\medskip\\
 This performances are dependant also from the goal node position in the search tree, the unexpected spike on the y axis with a sixteen table size configuration could be due to a disadvantageous placement of the goal node.\medskip\\
Comparatively, fig(5) underlines the gap between the just mentioned algorithm and Iterative Deepening Search or Astar with an admissible heuristic.\\
Both this strategies expanded huge quantities of nodes, much more than Depth First Algorithm.

					\subsection{Maximum Fringe size}
					
												
\begin{center}
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{QueenSearchPlotMaxQueueSizeComparison}
\caption{}
\label{fig:6}
\end{figure}
\end{center}


Last but not least, fig(6) demonstrates how the fringe is managed during the search from three different algorithms.\\
The first is again the Depth First Search which, by definition, remembers at most nodes equals to branching factor times the depth of the tree. So, it performs very well also with the increment of the board size.\medskip\\
The second is Breadth First Search that, again by definition, keeps in memory nodes for branching factor to the power of the depth of the solution. In fact, the chart shows this difference for board sizes from four to eight.\\
When I tried to run this algorithm on a grater board configuration, I run out of physical memory. \\
Finally the third, that corresponds to an Astar approach with admissible strategy, seems to have the same maximum fringe size as the second algorithm, at least until eight board size is reached. After that, the y axis value spikes exponentially but not at the point to forbid finding the solution.\\
Then again, when the ten board size milestone is exceeded, the time will became the bottleneck.

				\section{Fifteen Puzzle Tiles Problem}
					\subsection{Implementation}
					At first, I began building a parallel implementation of the java classes that represent the state and the goal check, following also the Factory pattern used in the AIMA project in the eight puzzle problem.\\
					Consequently, I implemented two admissible heuristics extending the already existing implementations.\\
					Finally I created the PuzzleInvoker class that, similarly to NqueensInvoker, provides static methods to the Plotter class in order to plot various algorithm performances on both problems.
					\subsection{Performances}
																	
\begin{center}
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{PuzzleSearchPlotTime}
\caption{}
\label{fig:7}
\end{figure}
\end{center}
					In fig(7) is extremely clear how a dominant heuristic outperforms a dominated one with the increment of complexity.
					The Manhattan approach applied to Astar algorithm, in the case of the Fifteen tiles Problem, is at least one order of magnitude faster than Misplaced Tiles heuristic used on the same algorithm.\\
				 	This enhancement is due to the different weight computed for the fringe nodes that, in case of a dominant heuristic, will allow a better approximation of convenient successors and it will decrease the overall expansion probability of profitless nodes.
					
				\section{Robot Maze Problem}
				\subsection{Implementation}
				In the same fashion to the puzzle problem, I designed the state with an Environment class,  I emulated the original project with a RobotFactory and a RobotGoalTest. I followed with the implementation of two heuristics which one is shown below in code \ref{heur}.

%Snippet of code
							\begin{lstlisting}[caption= Manhattan Heuristic, label=heur]
	public class ManhattanGridHeuristic implements HeuristicFunction {
	public double h(Object state) {
		Environment grid = (Environment) state;
		Position robot= grid.getRobot();
		Position goal= Environment.getGoal();
		return Math.abs(robot.x()-goal.x())+Math.abs(robot.y()-goal.y());
	}
}
							\end{lstlisting}
				Finally, I implemented the class PathPainter like in code \ref{painter}, to draw the path to the solution that inherits methods from RobotMover and returns a matrix of pixels with a drawn path.
				
%Snippet of code
							\begin{lstlisting}[caption= Path Painter, label=painter]
	public class PathPainter extends RobotMover {
		
	private int[][] grid;

	    public PathPainter(Position robot, int[][] occupancy){
	    	super(robot);
	    	this.grid= occupancy;
	    }

	    public int[][] paint(List<Action> actions){
			for (int i = 0; i < actions.size()-1; i++) {
        		if (actions.get(i).equals(LEFT)) {
        			this.moveRobLeft();
        		}else if (actions.get(i).equals(RIGHT)) {
        			this.moveRobRight();
        		}else if (actions.get(i).equals(UP)) {
        			this.moveRobUp();
        		}else if (actions.get(i).equals(DOWN)) {
        			this.moveRobDown();
        		}
        		int x_coord= this.getRobot().x();
        		int y_coord= this.getRobot().y();
        		this.grid[y_coord][x_coord]= 0xFF3333;
            }
        	return this.grid;
	    }

}
				\end{lstlisting}
				
				
				
				\subsection{Algorithms performances}
				
				After some experimentations, analysing the path chosen from the robot in fig(8), I concluded that a depth first approach won't ever find the optimal solution towards this kind of problems, if we suppose a minimal level of complexity of the problem.
		\begin{figure}[h]		
\centering
\includegraphics[width=0.6\textwidth]{DfsRobot1}
\caption{DFS algorithm}
\label{fig:8}
\end{figure}
				On the contrary, as can be seen in fig(9) and fig(10), Astar algorithm behaviour is efficient if is applied with a consistent heuristic.\\

\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Rob1}
  \caption{}
  \label{fig:9}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{AstarRobotSmart1}
  \caption{}
  \label{fig:10}
\end{subfigure}
\caption{Astar}
\label{fig:9,10}
\end{figure}
				In these two images the path found is optimum.	\\
				In particular in fig(10) there are two possible routes toward the solution and even if, initially, the former seems to be the right way in terms of Manhattan heuristic, the algorithms will return on his own steps choosing the latter due to an increasing path cost going on in the more convoluted path.\\
				Moreover, these figures distinguish themselves from each other because they have different dimensions from 16x16 to 128x128.\\
				In conclusion, I was forced using the \textit{ graph search}  approach over \textit{tree search} in order to avoid cycles that sometimes, for instance in the case of the Depth Search algorithm, will be in an infinite number.
\newpage		
\medskip
				\section{Conclusions}
				\medskip\medskip
				To sum up, one of the most important things, dealing with search problems is to identify the most convenient algorithm.\\
				For this reason, it is fundamental to formulate a coherent abstraction of the real problem and of course, if we are going to use some informed algorithms to choose the right heuristic to minimise the space of the search tree finish.
		\end{document}
